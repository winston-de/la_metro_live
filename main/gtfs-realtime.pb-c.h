/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: gtfs-realtime.proto */

#ifndef PROTOBUF_C_gtfs_2drealtime_2eproto__INCLUDED
#define PROTOBUF_C_gtfs_2drealtime_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protobuf-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1005002 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protobuf-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protobuf-c.
#endif


typedef struct FeedMessage FeedMessage;
typedef struct FeedHeader FeedHeader;
typedef struct FeedEntity FeedEntity;
typedef struct VehiclePosition VehiclePosition;
typedef struct VehiclePosition__CarriageDetails VehiclePosition__CarriageDetails;
typedef struct Position Position;
typedef struct TripDescriptor TripDescriptor;
typedef struct TripDescriptor__ModifiedTripSelector TripDescriptor__ModifiedTripSelector;
typedef struct VehicleDescriptor VehicleDescriptor;


/* --- enums --- */

/*
 * Determines whether the current fetch is incremental.  Currently,
 * DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
 * that use this mode.  There are discussions on the GTFS Realtime mailing
 * list around fully specifying the behavior of DIFFERENTIAL mode and the
 * documentation will be updated when those discussions are finalized.
 */
typedef enum _FeedHeader__Incrementality {
  FEED_HEADER__INCREMENTALITY__FULL_DATASET = 0,
  FEED_HEADER__INCREMENTALITY__DIFFERENTIAL = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(FEED_HEADER__INCREMENTALITY)
} FeedHeader__Incrementality;
typedef enum _VehiclePosition__VehicleStopStatus {
  /*
   * The vehicle is just about to arrive at the stop (on a stop
   * display, the vehicle symbol typically flashes).
   */
  VEHICLE_POSITION__VEHICLE_STOP_STATUS__INCOMING_AT = 0,
  /*
   * The vehicle is standing at the stop.
   */
  VEHICLE_POSITION__VEHICLE_STOP_STATUS__STOPPED_AT = 1,
  /*
   * The vehicle has departed and is in transit to the next stop.
   */
  VEHICLE_POSITION__VEHICLE_STOP_STATUS__IN_TRANSIT_TO = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(VEHICLE_POSITION__VEHICLE_STOP_STATUS)
} VehiclePosition__VehicleStopStatus;
/*
 * Congestion level that is affecting this vehicle.
 */
typedef enum _VehiclePosition__CongestionLevel {
  VEHICLE_POSITION__CONGESTION_LEVEL__UNKNOWN_CONGESTION_LEVEL = 0,
  VEHICLE_POSITION__CONGESTION_LEVEL__RUNNING_SMOOTHLY = 1,
  VEHICLE_POSITION__CONGESTION_LEVEL__STOP_AND_GO = 2,
  VEHICLE_POSITION__CONGESTION_LEVEL__CONGESTION = 3,
  /*
   * People leaving their cars.
   */
  VEHICLE_POSITION__CONGESTION_LEVEL__SEVERE_CONGESTION = 4
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(VEHICLE_POSITION__CONGESTION_LEVEL)
} VehiclePosition__CongestionLevel;
/*
 * The state of passenger occupancy for the vehicle or carriage.
 * Individual producers may not publish all OccupancyStatus values. Therefore, consumers
 * must not assume that the OccupancyStatus values follow a linear scale.
 * Consumers should represent OccupancyStatus values as the state indicated 
 * and intended by the producer. Likewise, producers must use OccupancyStatus values that
 * correspond to actual vehicle occupancy states.
 * For describing passenger occupancy levels on a linear scale, see `occupancy_percentage`.
 * This field is still experimental, and subject to change. It may be formally adopted in the future.
 */
typedef enum _VehiclePosition__OccupancyStatus {
  /*
   * The vehicle or carriage is considered empty by most measures, and has few or no
   * passengers onboard, but is still accepting passengers.
   */
  VEHICLE_POSITION__OCCUPANCY_STATUS__EMPTY = 0,
  /*
   * The vehicle or carriage has a large number of seats available.
   * The amount of free seats out of the total seats available to be
   * considered large enough to fall into this category is determined at the
   * discretion of the producer.
   */
  VEHICLE_POSITION__OCCUPANCY_STATUS__MANY_SEATS_AVAILABLE = 1,
  /*
   * The vehicle or carriage has a relatively small number of seats available.
   * The amount of free seats out of the total seats available to be
   * considered small enough to fall into this category is determined at the
   * discretion of the feed producer.
   */
  VEHICLE_POSITION__OCCUPANCY_STATUS__FEW_SEATS_AVAILABLE = 2,
  /*
   * The vehicle or carriage can currently accommodate only standing passengers.
   */
  VEHICLE_POSITION__OCCUPANCY_STATUS__STANDING_ROOM_ONLY = 3,
  /*
   * The vehicle or carriage can currently accommodate only standing passengers
   * and has limited space for them.
   */
  VEHICLE_POSITION__OCCUPANCY_STATUS__CRUSHED_STANDING_ROOM_ONLY = 4,
  /*
   * The vehicle or carriage is considered full by most measures, but may still be
   * allowing passengers to board.
   */
  VEHICLE_POSITION__OCCUPANCY_STATUS__FULL = 5,
  /*
   * The vehicle or carriage is not accepting passengers, but usually accepts passengers for boarding.
   */
  VEHICLE_POSITION__OCCUPANCY_STATUS__NOT_ACCEPTING_PASSENGERS = 6,
  /*
   * The vehicle or carriage doesn't have any occupancy data available at that time.
   */
  VEHICLE_POSITION__OCCUPANCY_STATUS__NO_DATA_AVAILABLE = 7,
  /*
   * The vehicle or carriage is not boardable and never accepts passengers.
   * Useful for special vehicles or carriages (engine, maintenance carriage, etc…).
   */
  VEHICLE_POSITION__OCCUPANCY_STATUS__NOT_BOARDABLE = 8
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(VEHICLE_POSITION__OCCUPANCY_STATUS)
} VehiclePosition__OccupancyStatus;
/*
 * The relation between this trip and the static schedule. If a trip is done
 * in accordance with temporary schedule, not reflected in GTFS, then it
 * shouldn't be marked as SCHEDULED, but likely as ADDED.
 */
typedef enum _TripDescriptor__ScheduleRelationship {
  /*
   * Trip that is running in accordance with its GTFS schedule, or is close
   * enough to the scheduled trip to be associated with it.
   */
  TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__SCHEDULED = 0,
  /*
   * This value has been deprecated as the behavior was unspecified. 
   * Use DUPLICATED for an extra trip that is the same as a scheduled trip except the start date or time, 
   * or NEW for an extra trip that is unrelated to an existing trip.
   */
  TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__ADDED = 1,
  /*
   * A trip that is running with no schedule associated to it (GTFS frequencies.txt exact_times=0).
   * Trips with ScheduleRelationship=UNSCHEDULED must also set all StopTimeUpdates.ScheduleRelationship=UNSCHEDULED.
   */
  TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__UNSCHEDULED = 2,
  /*
   * A trip that existed in the schedule but was removed.
   */
  TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__CANCELED = 3,
  /*
   * A trip that replaces an existing trip in the schedule.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__REPLACEMENT = 5,
  /*
   * An extra trip that was added in addition to a running schedule, for example, to replace a broken vehicle or to
   * respond to sudden passenger load. Used with TripUpdate.TripProperties.trip_id, TripUpdate.TripProperties.start_date,
   * and TripUpdate.TripProperties.start_time to copy an existing trip from static GTFS but start at a different service
   * date and/or time. Duplicating a trip is allowed if the service related to the original trip in (CSV) GTFS
   * (in calendar.txt or calendar_dates.txt) is operating within the next 30 days. The trip to be duplicated is
   * identified via TripUpdate.TripDescriptor.trip_id. This enumeration does not modify the existing trip referenced by
   * TripUpdate.TripDescriptor.trip_id - if a producer wants to cancel the original trip, it must publish a separate
   * TripUpdate with the value of CANCELED or DELETED. If a producer wants to replace the original trip, a value of 
   * `REPLACEMENT` should be used instead.
   * Trips defined in GTFS frequencies.txt with exact_times that is
   * empty or equal to 0 cannot be duplicated. The VehiclePosition.TripDescriptor.trip_id for the new trip must contain
   * the matching value from TripUpdate.TripProperties.trip_id and VehiclePosition.TripDescriptor.ScheduleRelationship
   * must also be set to DUPLICATED.
   * Existing producers and consumers that were using the ADDED enumeration to represent duplicated trips must follow
   * the migration guide (https://github.com/google/transit/tree/master/gtfs-realtime/spec/en/examples/migration-duplicated.md)
   * to transition to the DUPLICATED enumeration.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__DUPLICATED = 6,
  /*
   * A trip that existed in the schedule but was removed and must not be shown to users.
   * DELETED should be used instead of CANCELED to indicate that a transit provider would like to entirely remove
   * information about the corresponding trip from consuming applications, so the trip is not shown as cancelled to
   * riders, e.g. a trip that is entirely being replaced by another trip.
   * This designation becomes particularly important if several trips are cancelled and replaced with substitute service.
   * If consumers were to show explicit information about the cancellations it would distract from the more important
   * real-time predictions.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__DELETED = 7,
  /*
   * An extra trip unrelated to any existing trips, for example, to respond to sudden passenger load.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__NEW = 8
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP)
} TripDescriptor__ScheduleRelationship;
typedef enum _VehicleDescriptor__WheelchairAccessible {
  /*
   * The trip doesn't have information about wheelchair accessibility.
   * This is the **default** behavior. If the static GTFS contains a
   * _wheelchair_accessible_ value, it won't be overwritten.
   */
  VEHICLE_DESCRIPTOR__WHEELCHAIR_ACCESSIBLE__NO_VALUE = 0,
  /*
   * The trip has no accessibility value present.
   * This value will overwrite the value from the GTFS.
   */
  VEHICLE_DESCRIPTOR__WHEELCHAIR_ACCESSIBLE__UNKNOWN = 1,
  /*
   * The trip is wheelchair accessible.
   * This value will overwrite the value from the GTFS.
   */
  VEHICLE_DESCRIPTOR__WHEELCHAIR_ACCESSIBLE__WHEELCHAIR_ACCESSIBLE = 2,
  /*
   * The trip is **not** wheelchair accessible.
   * This value will overwrite the value from the GTFS.
   */
  VEHICLE_DESCRIPTOR__WHEELCHAIR_ACCESSIBLE__WHEELCHAIR_INACCESSIBLE = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(VEHICLE_DESCRIPTOR__WHEELCHAIR_ACCESSIBLE)
} VehicleDescriptor__WheelchairAccessible;

/* --- messages --- */

/*
 * The contents of a feed message.
 * A feed is a continuous stream of feed messages. Each message in the stream is
 * obtained as a response to an appropriate HTTP GET request.
 * A realtime feed is always defined with relation to an existing GTFS feed.
 * All the entity ids are resolved with respect to the GTFS feed.
 * Note that "required" and "optional" as stated in this file refer to Protocol
 * Buffer cardinality, not semantic cardinality.  See reference.md at
 * https://github.com/google/transit/tree/master/gtfs-realtime for field
 * semantic cardinality.
 */
struct  FeedMessage
{
  ProtobufCMessage base;
  /*
   * Metadata about this feed and feed message.
   */
  FeedHeader *header;
  /*
   * Contents of the feed.
   */
  size_t n_entity;
  FeedEntity **entity;
};
#define FEED_MESSAGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&feed_message__descriptor) \
, NULL, 0,NULL }


/*
 * Metadata about a feed, included in feed messages.
 */
struct  FeedHeader
{
  ProtobufCMessage base;
  /*
   * Version of the feed specification.
   * The current version is 2.0.  Valid versions are "2.0", "1.0".
   */
  char *gtfs_realtime_version;
  protobuf_c_boolean has_incrementality;
  FeedHeader__Incrementality incrementality;
  /*
   * This timestamp identifies the moment when the content of this feed has been
   * created (in server time). In POSIX time (i.e., number of seconds since
   * January 1st 1970 00:00:00 UTC).
   */
  protobuf_c_boolean has_timestamp;
  uint64_t timestamp;
  /*
   * String that matches the feed_info.feed_version from the GTFS feed that the real
   * time data is based on. Consumers can use this to identify which GTFS feed is
   * currently active or when a new one is available to download.
   */
  char *feed_version;
};
#define FEED_HEADER__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&feed_header__descriptor) \
, NULL, 0, FEED_HEADER__INCREMENTALITY__FULL_DATASET, 0, 0, NULL }


/*
 * A definition (or update) of an entity in the transit feed.
 */
struct  FeedEntity
{
  ProtobufCMessage base;
  /*
   * The ids are used only to provide incrementality support. The id should be
   * unique within a FeedMessage. Consequent FeedMessages may contain
   * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
   * FeedEntity with some id will replace the old FeedEntity with the same id
   * (or delete it - see is_deleted below).
   * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
   * feed must be specified by explicit selectors (see EntitySelector below for
   * more info).
   */
  char *id;
  /*
   * Whether this entity is to be deleted. Relevant only for incremental
   * fetches.
   */
  protobuf_c_boolean has_is_deleted;
  protobuf_c_boolean is_deleted;
  /*
   * Data about the entity itself. Exactly one of the following fields must be
   * present (unless the entity is being deleted).
   * optional TripUpdate trip_update = 3;
   */
  /*
   * optional Alert alert = 5;
   */
  VehiclePosition *vehicle;
};
#define FEED_ENTITY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&feed_entity__descriptor) \
, NULL, 0, 0, NULL }


/*
 * Carriage specific details, used for vehicles composed of several carriages
 * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
 */
struct  VehiclePosition__CarriageDetails
{
  ProtobufCMessage base;
  /*
   * Identification of the carriage. Should be unique per vehicle.
   */
  char *id;
  /*
   * User visible label that may be shown to the passenger to help identify
   * the carriage. Example: "7712", "Car ABC-32", etc...
   * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  char *label;
  /*
   * Occupancy status for this given carriage, in this vehicle
   * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  protobuf_c_boolean has_occupancy_status;
  VehiclePosition__OccupancyStatus occupancy_status;
  /*
   * Occupancy percentage for this given carriage, in this vehicle.
   * Follows the same rules as "VehiclePosition.occupancy_percentage"
   * -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise)
   * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  protobuf_c_boolean has_occupancy_percentage;
  int32_t occupancy_percentage;
  /*
   * Identifies the order of this carriage with respect to the other
   * carriages in the vehicle's list of CarriageDetails.
   * The first carriage in the direction of travel must have a value of 1.
   * The second value corresponds to the second carriage in the direction
   * of travel and must have a value of 2, and so forth.
   * For example, the first carriage in the direction of travel has a value of 1.
   * If the second carriage in the direction of travel has a value of 3,
   * consumers will discard data for all carriages (i.e., the multi_carriage_details field).
   * Carriages without data must be represented with a valid carriage_sequence number and the fields 
   * without data should be omitted (alternately, those fields could also be included and set to the "no data" values).
   * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  protobuf_c_boolean has_carriage_sequence;
  uint32_t carriage_sequence;
};
#define VEHICLE_POSITION__CARRIAGE_DETAILS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&vehicle_position__carriage_details__descriptor) \
, NULL, NULL, 0, VEHICLE_POSITION__OCCUPANCY_STATUS__NO_DATA_AVAILABLE, 0, -1, 0, 0 }


/*
 * Realtime positioning information for a given vehicle.
 */
struct  VehiclePosition
{
  ProtobufCMessage base;
  /*
   * The Trip that this vehicle is serving.
   * Can be empty or partial if the vehicle can not be identified with a given
   * trip instance.
   */
  TripDescriptor *trip;
  /*
   * Additional information on the vehicle that is serving this trip.
   */
  VehicleDescriptor *vehicle;
  /*
   * Current position of this vehicle.
   */
  Position *position;
  /*
   * The stop sequence index of the current stop. The meaning of
   * current_stop_sequence (i.e., the stop that it refers to) is determined by
   * current_status.
   * If current_status is missing IN_TRANSIT_TO is assumed.
   */
  protobuf_c_boolean has_current_stop_sequence;
  uint32_t current_stop_sequence;
  /*
   * Identifies the current stop. The value must be the same as in stops.txt in
   * the corresponding GTFS feed.
   */
  char *stop_id;
  /*
   * The exact status of the vehicle with respect to the current stop.
   * Ignored if current_stop_sequence is missing.
   */
  protobuf_c_boolean has_current_status;
  VehiclePosition__VehicleStopStatus current_status;
  /*
   * Moment at which the vehicle's position was measured. In POSIX time
   * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
   */
  protobuf_c_boolean has_timestamp;
  uint64_t timestamp;
  protobuf_c_boolean has_congestion_level;
  VehiclePosition__CongestionLevel congestion_level;
  /*
   * If multi_carriage_status is populated with per-carriage OccupancyStatus,
   * then this field should describe the entire vehicle with all carriages accepting passengers considered.
   */
  protobuf_c_boolean has_occupancy_status;
  VehiclePosition__OccupancyStatus occupancy_status;
  /*
   * A percentage value indicating the degree of passenger occupancy in the vehicle.
   * The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
   * The value 100 should represent the total maximum occupancy the vehicle was designed for,
   * including both seated and standing capacity, and current operating regulations allow.
   * The value may exceed 100 if there are more passengers than the maximum designed capacity.
   * The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle.
   * If multi_carriage_status is populated with per-carriage occupancy_percentage, 
   * then this field should describe the entire vehicle with all carriages accepting passengers considered.
   * This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  protobuf_c_boolean has_occupancy_percentage;
  uint32_t occupancy_percentage;
  /*
   * Details of the multiple carriages of this given vehicle.
   * The first occurrence represents the first carriage of the vehicle, 
   * given the current direction of travel. 
   * The number of occurrences of the multi_carriage_details 
   * field represents the number of carriages of the vehicle.
   * It also includes non boardable carriages, 
   * like engines, maintenance carriages, etc… as they provide valuable 
   * information to passengers about where to stand on a platform.
   * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  size_t n_multi_carriage_details;
  VehiclePosition__CarriageDetails **multi_carriage_details;
};
#define VEHICLE_POSITION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&vehicle_position__descriptor) \
, NULL, NULL, NULL, 0, 0, NULL, 0, VEHICLE_POSITION__VEHICLE_STOP_STATUS__IN_TRANSIT_TO, 0, 0, 0, VEHICLE_POSITION__CONGESTION_LEVEL__UNKNOWN_CONGESTION_LEVEL, 0, VEHICLE_POSITION__OCCUPANCY_STATUS__EMPTY, 0, 0, 0,NULL }


/*
 * A position.
 */
struct  Position
{
  ProtobufCMessage base;
  /*
   * Degrees North, in the WGS-84 coordinate system.
   */
  float latitude;
  /*
   * Degrees East, in the WGS-84 coordinate system.
   */
  float longitude;
  /*
   * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
   * This can be the compass bearing, or the direction towards the next stop
   * or intermediate location.
   * This should not be direction deduced from the sequence of previous
   * positions, which can be computed from previous data.
   */
  protobuf_c_boolean has_bearing;
  float bearing;
  /*
   * Odometer value, in meters.
   */
  protobuf_c_boolean has_odometer;
  double odometer;
  /*
   * Momentary speed measured by the vehicle, in meters per second.
   */
  protobuf_c_boolean has_speed;
  float speed;
};
#define POSITION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&position__descriptor) \
, 0, 0, 0, 0, 0, 0, 0, 0 }


struct  TripDescriptor__ModifiedTripSelector
{
  ProtobufCMessage base;
  /*
   * The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
   */
  char *modifications_id;
  /*
   * The trip_id from the GTFS feed that is modified by the modifications_id
   */
  char *affected_trip_id;
  /*
   * The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
   */
  char *start_time;
  /*
   * The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
   */
  char *start_date;
};
#define TRIP_DESCRIPTOR__MODIFIED_TRIP_SELECTOR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trip_descriptor__modified_trip_selector__descriptor) \
, NULL, NULL, NULL, NULL }


/*
 * A descriptor that identifies an instance of a GTFS trip, or all instances of
 * a trip along a route.
 * - To specify a single trip instance, the trip_id (and if necessary,
 *   start_time) is set. If route_id is also set, then it should be same as one
 *   that the given trip corresponds to.
 * - To specify all the trips along a given route, only the route_id should be
 *   set. Note that if the trip_id is not known, then stop sequence ids in
 *   TripUpdate are not sufficient, and stop_ids must be provided as well. In
 *   addition, absolute arrival/departure times must be provided.
 */
struct  TripDescriptor
{
  ProtobufCMessage base;
  /*
   * The trip_id from the GTFS feed that this selector refers to.
   * For non frequency-based trips, this field is enough to uniquely identify
   * the trip. For frequency-based trip, start_time and start_date might also be
   * necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
   * static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
   * identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
   */
  char *trip_id;
  /*
   * The route_id from the GTFS that this selector refers to.
   */
  char *route_id;
  /*
   * The direction_id from the GTFS feed trips.txt file, indicating the
   * direction of travel for trips this selector refers to.
   */
  protobuf_c_boolean has_direction_id;
  uint32_t direction_id;
  /*
   * The initially scheduled start time of this trip instance.
   * When the trip_id corresponds to a non-frequency-based trip, this field
   * should either be omitted or be equal to the value in the GTFS feed. When
   * the trip_id correponds to a frequency-based trip, the start_time must be
   * specified for trip updates and vehicle positions. If the trip corresponds
   * to exact_times=1 GTFS record, then start_time must be some multiple
   * (including zero) of headway_secs later than frequencies.txt start_time for
   * the corresponding time period. If the trip corresponds to exact_times=0,
   * then its start_time may be arbitrary, and is initially expected to be the
   * first departure of the trip. Once established, the start_time of this
   * frequency-based trip should be considered immutable, even if the first
   * departure time changes -- that time change may instead be reflected in a
   * StopTimeUpdate.
   * Format and semantics of the field is same as that of
   * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
   */
  char *start_time;
  /*
   * The scheduled start date of this trip instance.
   * Must be provided to disambiguate trips that are so late as to collide with
   * a scheduled trip on a next day. For example, for a train that departs 8:00
   * and 20:00 every day, and is 12 hours late, there would be two distinct
   * trips on the same time.
   * This field can be provided but is not mandatory for schedules in which such
   * collisions are impossible - for example, a service running on hourly
   * schedule where a vehicle that is one hour late is not considered to be
   * related to schedule anymore.
   * In YYYYMMDD format.
   */
  char *start_date;
  protobuf_c_boolean has_schedule_relationship;
  TripDescriptor__ScheduleRelationship schedule_relationship;
  /*
   * Linkage to any modifications done to this trip (shape changes, removal or addition of stops).
   * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value.
   */
  TripDescriptor__ModifiedTripSelector *modified_trip;
};
#define TRIP_DESCRIPTOR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trip_descriptor__descriptor) \
, NULL, NULL, 0, 0, NULL, NULL, 0, TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__SCHEDULED, NULL }


/*
 * Identification information for the vehicle performing the trip.
 */
struct  VehicleDescriptor
{
  ProtobufCMessage base;
  /*
   * Internal system identification of the vehicle. Should be unique per
   * vehicle, and can be used for tracking the vehicle as it proceeds through
   * the system.
   */
  char *id;
  /*
   * User visible label, i.e., something that must be shown to the passenger to
   * help identify the correct vehicle.
   */
  char *label;
  /*
   * The license plate of the vehicle.
   */
  char *license_plate;
  protobuf_c_boolean has_wheelchair_accessible;
  VehicleDescriptor__WheelchairAccessible wheelchair_accessible;
};
#define VEHICLE_DESCRIPTOR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&vehicle_descriptor__descriptor) \
, NULL, NULL, NULL, 0, VEHICLE_DESCRIPTOR__WHEELCHAIR_ACCESSIBLE__NO_VALUE }


/* FeedMessage methods */
void   feed_message__init
                     (FeedMessage         *message);
size_t feed_message__get_packed_size
                     (const FeedMessage   *message);
size_t feed_message__pack
                     (const FeedMessage   *message,
                      uint8_t             *out);
size_t feed_message__pack_to_buffer
                     (const FeedMessage   *message,
                      ProtobufCBuffer     *buffer);
FeedMessage *
       feed_message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   feed_message__free_unpacked
                     (FeedMessage *message,
                      ProtobufCAllocator *allocator);
/* FeedHeader methods */
void   feed_header__init
                     (FeedHeader         *message);
size_t feed_header__get_packed_size
                     (const FeedHeader   *message);
size_t feed_header__pack
                     (const FeedHeader   *message,
                      uint8_t             *out);
size_t feed_header__pack_to_buffer
                     (const FeedHeader   *message,
                      ProtobufCBuffer     *buffer);
FeedHeader *
       feed_header__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   feed_header__free_unpacked
                     (FeedHeader *message,
                      ProtobufCAllocator *allocator);
/* FeedEntity methods */
void   feed_entity__init
                     (FeedEntity         *message);
size_t feed_entity__get_packed_size
                     (const FeedEntity   *message);
size_t feed_entity__pack
                     (const FeedEntity   *message,
                      uint8_t             *out);
size_t feed_entity__pack_to_buffer
                     (const FeedEntity   *message,
                      ProtobufCBuffer     *buffer);
FeedEntity *
       feed_entity__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   feed_entity__free_unpacked
                     (FeedEntity *message,
                      ProtobufCAllocator *allocator);
/* VehiclePosition__CarriageDetails methods */
void   vehicle_position__carriage_details__init
                     (VehiclePosition__CarriageDetails         *message);
/* VehiclePosition methods */
void   vehicle_position__init
                     (VehiclePosition         *message);
size_t vehicle_position__get_packed_size
                     (const VehiclePosition   *message);
size_t vehicle_position__pack
                     (const VehiclePosition   *message,
                      uint8_t             *out);
size_t vehicle_position__pack_to_buffer
                     (const VehiclePosition   *message,
                      ProtobufCBuffer     *buffer);
VehiclePosition *
       vehicle_position__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   vehicle_position__free_unpacked
                     (VehiclePosition *message,
                      ProtobufCAllocator *allocator);
/* Position methods */
void   position__init
                     (Position         *message);
size_t position__get_packed_size
                     (const Position   *message);
size_t position__pack
                     (const Position   *message,
                      uint8_t             *out);
size_t position__pack_to_buffer
                     (const Position   *message,
                      ProtobufCBuffer     *buffer);
Position *
       position__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   position__free_unpacked
                     (Position *message,
                      ProtobufCAllocator *allocator);
/* TripDescriptor__ModifiedTripSelector methods */
void   trip_descriptor__modified_trip_selector__init
                     (TripDescriptor__ModifiedTripSelector         *message);
/* TripDescriptor methods */
void   trip_descriptor__init
                     (TripDescriptor         *message);
size_t trip_descriptor__get_packed_size
                     (const TripDescriptor   *message);
size_t trip_descriptor__pack
                     (const TripDescriptor   *message,
                      uint8_t             *out);
size_t trip_descriptor__pack_to_buffer
                     (const TripDescriptor   *message,
                      ProtobufCBuffer     *buffer);
TripDescriptor *
       trip_descriptor__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trip_descriptor__free_unpacked
                     (TripDescriptor *message,
                      ProtobufCAllocator *allocator);
/* VehicleDescriptor methods */
void   vehicle_descriptor__init
                     (VehicleDescriptor         *message);
size_t vehicle_descriptor__get_packed_size
                     (const VehicleDescriptor   *message);
size_t vehicle_descriptor__pack
                     (const VehicleDescriptor   *message,
                      uint8_t             *out);
size_t vehicle_descriptor__pack_to_buffer
                     (const VehicleDescriptor   *message,
                      ProtobufCBuffer     *buffer);
VehicleDescriptor *
       vehicle_descriptor__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   vehicle_descriptor__free_unpacked
                     (VehicleDescriptor *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*FeedMessage_Closure)
                 (const FeedMessage *message,
                  void *closure_data);
typedef void (*FeedHeader_Closure)
                 (const FeedHeader *message,
                  void *closure_data);
typedef void (*FeedEntity_Closure)
                 (const FeedEntity *message,
                  void *closure_data);
typedef void (*VehiclePosition__CarriageDetails_Closure)
                 (const VehiclePosition__CarriageDetails *message,
                  void *closure_data);
typedef void (*VehiclePosition_Closure)
                 (const VehiclePosition *message,
                  void *closure_data);
typedef void (*Position_Closure)
                 (const Position *message,
                  void *closure_data);
typedef void (*TripDescriptor__ModifiedTripSelector_Closure)
                 (const TripDescriptor__ModifiedTripSelector *message,
                  void *closure_data);
typedef void (*TripDescriptor_Closure)
                 (const TripDescriptor *message,
                  void *closure_data);
typedef void (*VehicleDescriptor_Closure)
                 (const VehicleDescriptor *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor feed_message__descriptor;
extern const ProtobufCMessageDescriptor feed_header__descriptor;
extern const ProtobufCEnumDescriptor    feed_header__incrementality__descriptor;
extern const ProtobufCMessageDescriptor feed_entity__descriptor;
extern const ProtobufCMessageDescriptor vehicle_position__descriptor;
extern const ProtobufCMessageDescriptor vehicle_position__carriage_details__descriptor;
extern const ProtobufCEnumDescriptor    vehicle_position__vehicle_stop_status__descriptor;
extern const ProtobufCEnumDescriptor    vehicle_position__congestion_level__descriptor;
extern const ProtobufCEnumDescriptor    vehicle_position__occupancy_status__descriptor;
extern const ProtobufCMessageDescriptor position__descriptor;
extern const ProtobufCMessageDescriptor trip_descriptor__descriptor;
extern const ProtobufCMessageDescriptor trip_descriptor__modified_trip_selector__descriptor;
extern const ProtobufCEnumDescriptor    trip_descriptor__schedule_relationship__descriptor;
extern const ProtobufCMessageDescriptor vehicle_descriptor__descriptor;
extern const ProtobufCEnumDescriptor    vehicle_descriptor__wheelchair_accessible__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_gtfs_2drealtime_2eproto__INCLUDED */
